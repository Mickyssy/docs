"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2881],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>g});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,p=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=l(n),g=o,u=h["".concat(p,".").concat(g)]||h[g]||c[g]||i;return n?a.createElement(u,r(r({ref:t},d),{},{components:n})):a.createElement(u,r({ref:t},d))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=h;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var l=2;l<i;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2779:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var a=n(7462),o=(n(7294),n(3905));const i={sidebar_position:5},r="\ud83e\uddd1\u200d\ud83d\udcbb Radio Development",s={unversionedId:"graphcast/radio-dev",id:"graphcast/radio-dev",title:"\ud83e\uddd1\u200d\ud83d\udcbb Radio Development",description:"Do you want to build robust, peer-to-peer messaging apps that automatically exchanges valuable data with other Indexers in real time? Do you have an idea for what data could be useful to share that could lead to greater communication efficiency in The Graph network as a whole? Then you want to build a Radio on top of the Graphcast network.",source:"@site/docs/graphcast/radio-dev.md",sourceDirName:"graphcast",slug:"/graphcast/radio-dev",permalink:"/graphcast/radio-dev",draft:!1,editUrl:"https://github.com/graphops/docs/edit/main/docs/graphcast/radio-dev.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"gnSidebar",previous:{title:"\ud83d\udcfb Radios",permalink:"/graphcast/radios"}},p={},l=[{value:"A simple ping pong example",id:"a-simple-ping-pong-example",level:2},{value:"Register an operator address",id:"register-an-operator-address",level:3},{value:"Populate your <code>.env</code> file",id:"populate-your-env-file",level:3},{value:"A few dependencies",id:"a-few-dependencies",level:3},{value:"The imports",id:"the-imports",level:3},{value:"Set up a few constants",id:"set-up-a-few-constants",level:3},{value:"Structure",id:"structure",level:3},{value:"Instantiate the essentials",id:"instantiate-the-essentials",level:3},{value:"Making sure everything works",id:"making-sure-everything-works",level:3},{value:"Sending messages",id:"sending-messages",level:3},{value:"Receiving and handling messages",id:"receiving-and-handling-messages",level:3},{value:"The main loop",id:"the-main-loop",level:3},{value:"The finished Radio",id:"the-finished-radio",level:3},{value:"That&#39;s awesome. But how do we run it?",id:"thats-awesome-but-how-do-we-run-it",level:3},{value:"OK. Here&#39;s the moment we&#39;ve all been waiting for",id:"ok-heres-the-moment-weve-all-been-waiting-for",level:3}],d={toc:l};function c(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"-radio-development"},"\ud83e\uddd1\u200d\ud83d\udcbb Radio Development"),(0,o.kt)("p",null,"Do you want to build robust, peer-to-peer messaging apps that automatically exchanges valuable data with other Indexers in real time? Do you have an idea for what data could be useful to share that could lead to greater communication efficiency in The Graph network as a whole? Then you want to build a Radio on top of the Graphcast network."),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"As of today, the Graphcast SDK is not a separate npm package, but the examples below will clearly illustrate how functions and classes would be imported from it and used once it gets published. It should be treated as pseudocode for the time being and will not work properly if you try to run it on its own.")),(0,o.kt)("p",null,"For a more complex and full example of the Graphcast SDK being used to create a POI cross-checker Radio, take a look at this ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/graphops/graphcast-poc/tree/main/src/examples/poi-crosschecker"},"implementation in the POC repo"),"."),(0,o.kt)("h2",{id:"a-simple-ping-pong-example"},"A simple ping pong example"),(0,o.kt)("p",null,"Let's take a look at the simples possible example of a Radio, built on top of Graphcast - a ping pong app. When one participant sends ",(0,o.kt)("inlineCode",{parentName:"p"},"Ping"),", all the others in the network are listening on the ping pong topic will send ",(0,o.kt)("inlineCode",{parentName:"p"},"Pong")," back. Pretty straightforward."),(0,o.kt)("h3",{id:"register-an-operator-address"},"Register an operator address"),(0,o.kt)("p",null,"First things first - before you can run any Radio on Graphcast, you need to register an operator address for your on-chain Indexer address. You can do that by using our ",(0,o.kt)("a",{parentName:"p",href:"https://goerli.etherscan.io/address/0x1e408c2cf66fd3afcea0f49dc44c9f4db5575e79"},"Registry smart contract")," (on the Goerli network)."),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"The easiest way to do that is through ",(0,o.kt)("a",{parentName:"p",href:"https://remix.ethereum.org/"},"Remix")," (you can check out ",(0,o.kt)("a",{parentName:"p",href:"https://medium.com/blockchain-stories/interacting-with-an-ethereum-smart-contract-aa14401c30a0"},"this guide"),"). You need to use your Indexer wallet to call the ",(0,o.kt)("inlineCode",{parentName:"p"},"setGossipOperator")," function, providing the address you wish to use as an operator (in all lower-case characters). You can find the contract abi ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/graphops/graphcast-poc/blob/main/registryAbi.json"},"here"),".")),(0,o.kt)("p",null,"Once that's done, you can start building your very first Radio."),(0,o.kt)("h3",{id:"populate-your-env-file"},"Populate your ",(0,o.kt)("inlineCode",{parentName:"h3"},".env")," file"),(0,o.kt)("p",null,"You now need to specify five essential variables in your ",(0,o.kt)("inlineCode",{parentName:"p"},".env")," file, here's the ",(0,o.kt)("inlineCode",{parentName:"p"},".env.example"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"ETH_NODE=\nRADIO_OPERATOR_PRIVATE_KEY=\nNETWORK_SUBGRAPH=\nINDEXER_MANAGEMENT_SERVER=\nGRAPH_NODE=\n")),(0,o.kt)("p",null,"Please use a Goerli ETH node for this example (doesn't need to be a full node)."),(0,o.kt)("h3",{id:"a-few-dependencies"},"A few dependencies"),(0,o.kt)("p",null,"For this example you need to have the ",(0,o.kt)("inlineCode",{parentName:"p"},"@graphops/graphcast"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"dotenv")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"@graphprotocol/common-ts")," npm packages installed."),(0,o.kt)("h3",{id:"the-imports"},"The imports"),(0,o.kt)("p",null,"Create a new file, for instance we'll be using ",(0,o.kt)("inlineCode",{parentName:"p"},"index.ts"),", and import the following packages:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'import "dotenv/config";\nimport { ClientManager, GossipAgent } from "@graphops";\nimport { createLogger } from "@graphprotocol/common-ts";\n')),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"If you need a refresher on what ",(0,o.kt)("inlineCode",{parentName:"p"},"ClientManager")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"GossipAgent")," do, refer to ",(0,o.kt)("a",{parentName:"p",href:"http://docs.graphops.xyz/graphcast/sdk#gossip-agent"},"this earlier section of the Graphcast docs"),".")),(0,o.kt)("h3",{id:"set-up-a-few-constants"},"Set up a few constants"),(0,o.kt)("p",null,"Add these constants right after the imports:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'const RADIO_PAYLOAD_TYPES = [{ name: "content", type: "string" }];\nconst DOMAIN = "ping-pong";\n\nconst logger = createLogger({\n  name: DOMAIN,\n  async: false,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  level: process.env.logLevel as any,\n});\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"RADIO_PAYLOAD_TYPES")," defines the types for our Radio-specific message payload.\n",(0,o.kt)("inlineCode",{parentName:"p"},"DOMAIN")," is the unique name of the Radio, which is used in many places, but mainly to construct message topics."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Topics in the Graphcast network use the following format - ",(0,o.kt)("inlineCode",{parentName:"p"},"/graphcast/{version}/{domain}/{subtopic}/proto}"),". In our ping pong example we won't need a ",(0,o.kt)("inlineCode",{parentName:"p"},"subtopic"),", which is an optional field where the topics need to branch out (as is the case in the POI cross-checker radio, where a subgraph hash is provided as a ",(0,o.kt)("inlineCode",{parentName:"p"},"subtopic"),", because rarely an Indexer would want to listen for POIs for ",(0,o.kt)("strong",{parentName:"p"},"all")," the subgraphs). But in the current case our topic will look like this - ",(0,o.kt)("inlineCode",{parentName:"p"},"/graphcast/0/ping-pong/proto"),".")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"logger")," will be used to structure logs in a better way than the good ol' ",(0,o.kt)("inlineCode",{parentName:"p"},"console.log")," (very important if we want to have better tracing and metrics in the future)."),(0,o.kt)("h3",{id:"structure"},"Structure"),(0,o.kt)("p",null,"The most basic structure of our ping pong code that we can have is to put everything below the imports and the constants in one ",(0,o.kt)("inlineCode",{parentName:"p"},"run()")," function, which can looks something like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const run = async () => {\n  // TODO: Ping pong \ud83c\udfd3\n};\n\nrun()\n  .then()\n  .catch((err) => {\n    logger.error(`\u274c Oh no! An error occurred: ${err.message}`);\n    process.exit(1);\n  });\n")),(0,o.kt)("p",null,"From here on out everything we write will reside in the ",(0,o.kt)("inlineCode",{parentName:"p"},"run()")," function."),(0,o.kt)("h3",{id:"instantiate-the-essentials"},"Instantiate the essentials"),(0,o.kt)("p",null,"Let's instantiate a few classes that will do all the heavy lifting for us:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const clientManager = new ClientManager({\n  operatorPrivateKey: process.env.RADIO_OPERATOR_PRIVATE_KEY,\n  ethNodeUrl: process.env.ETH_NODE,\n  registry: process.env.REGISTRY_SUBGRAPH,\n  graphNodeStatus: process.env.GRAPH_NODE,\n  indexerManagementServer: process.env.INDEXER_MANAGEMENT_SERVER,\n  graphNetworkUrl: process.env.NETWORK_SUBGRAPH,\n});\n\nconst gossipAgent = new GossipAgent(logger, clientManager);\n")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Don't worry about the environment variables that you see there which we haven't added to the ",(0,o.kt)("inlineCode",{parentName:"p"},".env"),", they will reside in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Dockerfile")," that we'll create at the end.")),(0,o.kt)("h3",{id:"making-sure-everything-works"},"Making sure everything works"),(0,o.kt)("p",null,"This next segment will make sure that our operator gets resolved to an on-chain Indexer address and that we're ready to start sending and receiving message via Graphcast."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'const indexerAddress = await gossipAgent.init();\n\nlogger.info(`\ud83d\udd26 Radio operator resolved to indexer address ${indexerAddress}`);\n\nlogger.info(`\ud83d\udc42 Initialize ping pong Radio with operator status: `, {\n  indexerAddress:\n    indexerAddress ??\n    "Graphcast agent is not registered as an indexer operator",\n  topic: DOMAIN,\n});\n')),(0,o.kt)("h3",{id:"sending-messages"},"Sending messages"),(0,o.kt)("p",null,"Next, we will define a helper function (still inside of the ",(0,o.kt)("inlineCode",{parentName:"p"},"run")," function) which will take care of sending messages to the network."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'const sendMessage = async (radioPayload) => {\n  const provider = gossipAgent.clientManager.ethClient.provider;\n\n  const block = await provider.getBlockNumber();\n  const blockObject = await provider.getBlock(block);\n\n  logger.info("Sending message with payload: ", radioPayload);\n\n  const encodedMessage = await gossipAgent.messenger.writeMessage({\n    radioPayload,\n    types: RADIO_PAYLOAD_TYPES,\n    block: blockObject,\n  });\n\n  await gossipAgent.messenger.sendMessage(encodedMessage, DOMAIN);\n};\n')),(0,o.kt)("p",null,"The function accepts ",(0,o.kt)("inlineCode",{parentName:"p"},"radioPaylaod"),", which currently can be any arbitrary TS object (this will certainly change in the future). It uses an Ethereum provider from ",(0,o.kt)("inlineCode",{parentName:"p"},"gossipAgent")," to fetch the latest block, along with its metadata. Then we encode the message using ",(0,o.kt)("inlineCode",{parentName:"p"},"writeMessage")," and propagate it onto the network with ",(0,o.kt)("inlineCode",{parentName:"p"},"sendMessage"),"."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"We are setting the message topic to be the same as the ",(0,o.kt)("inlineCode",{parentName:"p"},"DOMAIN")," constant.")),(0,o.kt)("h3",{id:"receiving-and-handling-messages"},"Receiving and handling messages"),(0,o.kt)("p",null,"We now know how to send message, but how do we receive and handle message from other network participants?"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'const handler = async (msg: Uint8Array, topic: string) => {\n  try {\n    logger.info(`\ud83d\udcee A new message has been received! Handling the message`);\n    const message = await gossipAgent.processMessage({\n      msg,\n      topic,\n      types: RADIO_PAYLOAD_TYPES,\n    });\n\n    logger.info(`Message: `, { message });\n    const radioPayload = JSON.parse(message.radioPayload);\n\n    if (radioPayload.content === "Ping") {\n      const radioPayload = {\n        content: "Pong",\n      };\n\n      await sendMessage(radioPayload);\n    }\n  } catch (error) {\n    logger.info(`Failed to handle the message, moving on. ${error}`);\n  }\n};\n\nawait gossipAgent.establishTopics(DOMAIN, handler);\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"handler")," function accepts a message of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Uint8Array")," (bytes), and of course the topic it was received on. At this point, the message is still encoded, but we can decode it using the SDK helper method ",(0,o.kt)("inlineCode",{parentName:"p"},"processMessage")," with the ",(0,o.kt)("inlineCode",{parentName:"p"},"RADIO_PAYLOAD_TYPES")," variable we defined before (because it was also used to encode it on the sender side). After it's decoded we can inspect the incoming ",(0,o.kt)("inlineCode",{parentName:"p"},"radioPayload")," and read the ",(0,o.kt)("inlineCode",{parentName:"p"},"content")," variable. Right after the function definition we can pass it to ",(0,o.kt)("inlineCode",{parentName:"p"},"establishTopics"),". We've now started listening to messages \ud83d\udc42."),(0,o.kt)("h3",{id:"the-main-loop"},"The main loop"),(0,o.kt)("p",null,"Great, we're almost there! We have a way to pass messages back and forth \ud83c\udfd3. But sending a one-off message is no fun, we want to create some sort of scheduled and continuous logic of message exchange, and perhaps the easiest way to do that is to use the Ethereum block number as cue. For instance we can set a schedule where the message is sent when we hit a block that is divisible by 5."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'gossipAgent.clientManager.ethClient.provider.on("block", async (block) => {\n  logger.info(`\ud83d\udd17 Block: ${block}`);\n\n  if (block % 5 === 0) {\n    logger.info("Ping pong block!");\n\n    const radioPayload = {\n      content: "Ping",\n    };\n\n    await sendMessage(radioPayload);\n  }\n});\n')),(0,o.kt)("h3",{id:"the-finished-radio"},"The finished Radio"),(0,o.kt)("p",null,"Congratulations, you've now written you first full Graphcast Radio! The finished code is also available in ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/graphops/graphcast-poc/tree/main/src/examples/ping-pong"},"this repo"),", the only important difference is in the imports."),(0,o.kt)("h3",{id:"thats-awesome-but-how-do-we-run-it"},"That's awesome. But how do we run it?"),(0,o.kt)("p",null,"We can of course run this as a standalone NodeJS process, but let's take it a step further and put it into a Docker container, using the following ",(0,o.kt)("inlineCode",{parentName:"p"},"Dockerfile"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-Docker"},'FROM alpine:latest\n\nRUN apk add --update nodejs npm\n\nWORKDIR /usr/app\nCOPY package.json ./\nRUN npm install\n\nCOPY . .\nRUN npm run build\n\nWORKDIR /usr/app/dist/src/examples/ping-pong\n\nENV TERM "xterm-256color"\nENV LOG_LEVEL "trace"\nENV REGISTRY_SUBGRAPH "https://api.thegraph.com/subgraphs/name/hopeyen/gossip-registry-test"\n\nCMD node index.js\n')),(0,o.kt)("p",null,"We can take it even a step further and make our lives easier by using a ",(0,o.kt)("inlineCode",{parentName:"p"},"docker-compose.yml")," file."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'version: "3.8"\n\nservices:\n  ping-pong:\n    build:\n      context: .\n      dockerfile: ./pingpong.Dockerfile\n    command: node index.js\n    env_file:\n      - .env\n')),(0,o.kt)("h3",{id:"ok-heres-the-moment-weve-all-been-waiting-for"},"OK. Here's the moment we've all been waiting for"),(0,o.kt)("p",null,"To start up our ping pong Radio, simply run the following command to spin up two instances of the Radio that will pass around the ball between each other ",(0,o.kt)("em",{parentName:"p"},"in perpetuum"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"docker-compose up ping-pong --scale ping-pong=2\n")),(0,o.kt)("p",null,"Now there's just one more thing to do - have fun examining the logs & be proud of yourself - you made it! \ud83e\udd42 From here on out, the only limit to the Radios you can build is your own imagination."))}c.isMDXComponent=!0}}]);