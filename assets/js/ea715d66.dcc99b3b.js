"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5207],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>u});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function o(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},s=Object.keys(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,s=e.originalType,c=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),h=l(r),u=a,m=h["".concat(c,".").concat(u)]||h[u]||d[u]||s;return r?n.createElement(m,i(i({ref:t},p),{},{components:r})):n.createElement(m,i({ref:t},p))}));function u(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=r.length,i=new Array(s);i[0]=h;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var l=2;l<s;l++)i[l]=r[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},3138:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var n=r(7462),a=(r(7294),r(3905));const s={sidebar_position:2},i="\u2699\ufe0f Design Principles",o={unversionedId:"graphcast/design-principles",id:"graphcast/design-principles",title:"\u2699\ufe0f Design Principles",description:"There are two main components of Graphcast",source:"@site/docs/graphcast/design-principles.md",sourceDirName:"graphcast",slug:"/graphcast/design-principles",permalink:"/graphcast/design-principles",draft:!1,editUrl:"https://github.com/graphops/docs/edit/main/docs/graphcast/design-principles.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"gnSidebar",previous:{title:"\ud83d\udc4b Introduction",permalink:"/graphcast/intro"},next:{title:"\ud83e\uddf0 SDK",permalink:"/graphcast/sdk"}},c={},l=[{value:"The Graphcast SDK",id:"the-graphcast-sdk",level:2},{value:"Radios",id:"radios",level:2}],p={toc:l};function d(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"\ufe0f-design-principles"},"\u2699\ufe0f Design Principles"),(0,a.kt)("p",null,"There are two main components of Graphcast"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The Graphcast SDK: The base layer SDK which interfaces with The Graph stack and the Waku network. This includes interactions with an Ethereum client, a Graph node client, a client for the Indexer management server, the Network subgraph and the Registry subgraph)."),(0,a.kt)("li",{parentName:"ul"},"Radios: Highly customizable gossip applications, built with the help of the Graphcast SDK, which define the specific message formats and logic around constructing and handling the messages.")),(0,a.kt)("h2",{id:"the-graphcast-sdk"},"The Graphcast SDK"),(0,a.kt)("p",null,"The SDK is the base layer which is used to abstract all the necessary components of each Radio away from the user. That includes:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Connection to Graphcast by spinning up a ",(0,a.kt)("a",{parentName:"li",href:"https://waku.org/"},"Waku")," node. It also provides an interface to subscribe to receive messages on specific topics and to broadcast messages onto the network."),(0,a.kt)("li",{parentName:"ul"},"Interactions with an Ethereum node, a Graph node and a client for the Indexer management server."),(0,a.kt)("li",{parentName:"ul"},"Queries to Network and Registry subgraphs."),(0,a.kt)("li",{parentName:"ul"},"Checks message validity for past message injections, nonexistent blocks and expired timestamps. It also guarantees that messages are signed by an authorised operator address of an active on-chain Indexer (this can be used as a basis for a reputation system).")),(0,a.kt)("h2",{id:"radios"},"Radios"),(0,a.kt)("p",null,"Our first example Radio is built for real-time cross-checking of Indexer Proof of Indexing attestations (POIs). Indexers must generate valid POIs to earn indexing rewards. Indexers find it beneficial to alert each other on the health status of subgraphs in community discussions. To alleviate the manual workload, the POI cross-checker Radio:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Defines message types and topics"),(0,a.kt)("li",{parentName:"ul"},"Collects POIs from the Graph node and sends them inside of Graphcast messages along with other useful metadata"),(0,a.kt)("li",{parentName:"ul"},"Observes relevant messages and aggregates POIs sent from other Indexers, in order to compare ",(0,a.kt)("em",{parentName:"li"},"local")," POIs to ",(0,a.kt)("em",{parentName:"li"},"remote")," POIs"),(0,a.kt)("li",{parentName:"ul"},"Monitors the network for conflicts and makes updates to the Indexer stack if needed. In the case of the POI cross-checker Radio, the agent sets the Indexer's cost model to a high constant to avoid query volume.")))}d.isMDXComponent=!0}}]);